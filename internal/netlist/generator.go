// Package netlist provides netlist generation and export functionality.
package netlist

import (
	"encoding/json"
	"fmt"
	"os"
	"sort"
	"strings"

	"pcb-tracer/internal/component"
)

// Net represents a single electrical net (connection).
type Net struct {
	Name        string       `json:"name"`
	Connections []Connection `json:"connections"`
}

// Connection represents a component pin connection.
type Connection struct {
	ComponentID string `json:"component"`
	PinNumber   int    `json:"pin"`
	PinName     string `json:"pin_name,omitempty"`
}

// Netlist represents the complete netlist of a PCB.
type Netlist struct {
	Name       string `json:"name"`
	Version    string `json:"version"`
	Components []*component.Component `json:"components"`
	Nets       []*Net `json:"nets"`
}

// NewNetlist creates a new empty netlist.
func NewNetlist(name string) *Netlist {
	return &Netlist{
		Name:    name,
		Version: "1.0",
	}
}

// AddComponent adds a component to the netlist.
func (n *Netlist) AddComponent(c *component.Component) {
	n.Components = append(n.Components, c)
}

// AddNet adds a net to the netlist.
func (n *Netlist) AddNet(net *Net) {
	n.Nets = append(n.Nets, net)
}

// FindNet finds a net by name.
func (n *Netlist) FindNet(name string) *Net {
	for _, net := range n.Nets {
		if net.Name == name {
			return net
		}
	}
	return nil
}

// GetOrCreateNet returns an existing net or creates a new one.
func (n *Netlist) GetOrCreateNet(name string) *Net {
	if net := n.FindNet(name); net != nil {
		return net
	}
	net := &Net{Name: name}
	n.Nets = append(n.Nets, net)
	return net
}

// ConnectPins connects two component pins via a net.
func (n *Netlist) ConnectPins(netName string, comp1 string, pin1 int, comp2 string, pin2 int) {
	net := n.GetOrCreateNet(netName)

	// Add connections if not already present
	hasConn1 := false
	hasConn2 := false
	for _, conn := range net.Connections {
		if conn.ComponentID == comp1 && conn.PinNumber == pin1 {
			hasConn1 = true
		}
		if conn.ComponentID == comp2 && conn.PinNumber == pin2 {
			hasConn2 = true
		}
	}

	if !hasConn1 {
		net.Connections = append(net.Connections, Connection{ComponentID: comp1, PinNumber: pin1})
	}
	if !hasConn2 {
		net.Connections = append(net.Connections, Connection{ComponentID: comp2, PinNumber: pin2})
	}
}

// SortNets sorts nets alphabetically by name.
func (n *Netlist) SortNets() {
	sort.Slice(n.Nets, func(i, j int) bool {
		return n.Nets[i].Name < n.Nets[j].Name
	})
}

// ExportJSON exports the netlist to JSON format.
func (n *Netlist) ExportJSON(path string) error {
	data, err := json.MarshalIndent(n, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal netlist: %w", err)
	}
	return os.WriteFile(path, data, 0644)
}

// LoadJSON loads a netlist from JSON format.
func LoadJSON(path string) (*Netlist, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read file: %w", err)
	}

	var netlist Netlist
	if err := json.Unmarshal(data, &netlist); err != nil {
		return nil, fmt.Errorf("failed to unmarshal netlist: %w", err)
	}

	return &netlist, nil
}

// ExportKiCad exports the netlist in KiCad format (.net).
func (n *Netlist) ExportKiCad(path string) error {
	var sb strings.Builder

	// Header
	sb.WriteString("(export (version \"E\")\n")
	sb.WriteString("  (design\n")
	sb.WriteString(fmt.Sprintf("    (source \"%s\")\n", n.Name))
	sb.WriteString("    (tool \"pcb-tracer 0.1.0\")\n")
	sb.WriteString("  )\n")

	// Components
	sb.WriteString("  (components\n")
	for _, comp := range n.Components {
		sb.WriteString(fmt.Sprintf("    (comp (ref \"%s\")\n", comp.ID))
		if comp.PartNumber != "" {
			sb.WriteString(fmt.Sprintf("      (value \"%s\")\n", comp.PartNumber))
		}
		if comp.Package != "" {
			sb.WriteString(fmt.Sprintf("      (footprint \"%s\")\n", comp.Package))
		}
		sb.WriteString("    )\n")
	}
	sb.WriteString("  )\n")

	// Nets
	sb.WriteString("  (nets\n")
	for i, net := range n.Nets {
		sb.WriteString(fmt.Sprintf("    (net (code \"%d\") (name \"%s\")\n", i+1, net.Name))
		for _, conn := range net.Connections {
			sb.WriteString(fmt.Sprintf("      (node (ref \"%s\") (pin \"%d\"))\n", conn.ComponentID, conn.PinNumber))
		}
		sb.WriteString("    )\n")
	}
	sb.WriteString("  )\n")

	// Footer
	sb.WriteString(")\n")

	return os.WriteFile(path, []byte(sb.String()), 0644)
}

// ExportSPICE exports the netlist in SPICE format (.cir).
func (n *Netlist) ExportSPICE(path string) error {
	var sb strings.Builder

	// Title
	sb.WriteString(fmt.Sprintf("* %s\n", n.Name))
	sb.WriteString("* Generated by pcb-tracer\n")
	sb.WriteString("\n")

	// Components as comments (SPICE needs device models)
	sb.WriteString("* Components:\n")
	for _, comp := range n.Components {
		sb.WriteString(fmt.Sprintf("* %s: %s (%s)\n", comp.ID, comp.PartNumber, comp.Package))
	}
	sb.WriteString("\n")

	// Nets
	sb.WriteString("* Nets:\n")
	for _, net := range n.Nets {
		sb.WriteString(fmt.Sprintf("* %s:", net.Name))
		for _, conn := range net.Connections {
			sb.WriteString(fmt.Sprintf(" %s.%d", conn.ComponentID, conn.PinNumber))
		}
		sb.WriteString("\n")
	}
	sb.WriteString("\n")

	// End
	sb.WriteString(".END\n")

	return os.WriteFile(path, []byte(sb.String()), 0644)
}

// Statistics returns statistics about the netlist.
type Statistics struct {
	ComponentCount int
	NetCount       int
	ConnectionCount int
	UnconnectedPins int
}

// GetStatistics returns statistics about the netlist.
func (n *Netlist) GetStatistics() Statistics {
	stats := Statistics{
		ComponentCount: len(n.Components),
		NetCount:       len(n.Nets),
	}

	connectedPins := make(map[string]bool)
	for _, net := range n.Nets {
		stats.ConnectionCount += len(net.Connections)
		for _, conn := range net.Connections {
			key := fmt.Sprintf("%s.%d", conn.ComponentID, conn.PinNumber)
			connectedPins[key] = true
		}
	}

	// Count unconnected pins
	for _, comp := range n.Components {
		for _, pin := range comp.Pins {
			key := fmt.Sprintf("%s.%d", comp.ID, pin.Number)
			if !connectedPins[key] {
				stats.UnconnectedPins++
			}
		}
	}

	return stats
}
