// Package netlist provides netlist generation and export functionality.
package netlist

import (
	"encoding/json"
	"fmt"
	"os"
	"sort"
	"strings"

	"pcb-tracer/internal/component"
)

// Net represents a single electrical net (connection).
type Net struct {
	Name        string       `json:"name"`
	Connections []Connection `json:"connections"`
}

// Connection represents a component pin connection.
type Connection struct {
	ComponentID string `json:"component"`
	PinNumber   int    `json:"pin"`
	PinName     string `json:"pin_name,omitempty"`
}

// Netlist represents the complete netlist of a PCB.
type Netlist struct {
	Name       string `json:"name"`
	Version    string `json:"version"`
	Components []*component.Component `json:"components"`
	Nets       []*Net `json:"nets"`
}

// NewNetlist creates a new empty netlist.
func NewNetlist(name string) *Netlist {
	return &Netlist{
		Name:    name,
		Version: "1.0",
	}
}

// AddComponent adds a component to the netlist.
func (n *Netlist) AddComponent(c *component.Component) {
	n.Components = append(n.Components, c)
}

// AddNet adds a net to the netlist.
func (n *Netlist) AddNet(net *Net) {
	n.Nets = append(n.Nets, net)
}

// FindNet finds a net by name.
func (n *Netlist) FindNet(name string) *Net {
	for _, net := range n.Nets {
		if net.Name == name {
			return net
		}
	}
	return nil
}

// GetOrCreateNet returns an existing net or creates a new one.
func (n *Netlist) GetOrCreateNet(name string) *Net {
	if net := n.FindNet(name); net != nil {
		return net
	}
	net := &Net{Name: name}
	n.Nets = append(n.Nets, net)
	return net
}

// ConnectPins connects two component pins via a net.
func (n *Netlist) ConnectPins(netName string, comp1 string, pin1 int, comp2 string, pin2 int) {
	net := n.GetOrCreateNet(netName)

	// Add connections if not already present
	hasConn1 := false
	hasConn2 := false
	for _, conn := range net.Connections {
		if conn.ComponentID == comp1 && conn.PinNumber == pin1 {
			hasConn1 = true
		}
		if conn.ComponentID == comp2 && conn.PinNumber == pin2 {
			hasConn2 = true
		}
	}

	if !hasConn1 {
		net.Connections = append(net.Connections, Connection{ComponentID: comp1, PinNumber: pin1})
	}
	if !hasConn2 {
		net.Connections = append(net.Connections, Connection{ComponentID: comp2, PinNumber: pin2})
	}
}

// SortNets sorts nets alphabetically by name.
func (n *Netlist) SortNets() {
	sort.Slice(n.Nets, func(i, j int) bool {
		return n.Nets[i].Name < n.Nets[j].Name
	})
}

// ExportJSON exports the netlist to JSON format.
func (n *Netlist) ExportJSON(path string) error {
	data, err := json.MarshalIndent(n, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal netlist: %w", err)
	}
	return os.WriteFile(path, data, 0644)
}

// LoadJSON loads a netlist from JSON format.
func LoadJSON(path string) (*Netlist, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read file: %w", err)
	}

	var netlist Netlist
	if err := json.Unmarshal(data, &netlist); err != nil {
		return nil, fmt.Errorf("failed to unmarshal netlist: %w", err)
	}

	return &netlist, nil
}

// ExportKiCad exports the netlist in KiCad format (.net).
func (n *Netlist) ExportKiCad(path string) error {
	var sb strings.Builder

	// Header
	sb.WriteString("(export (version \"E\")\n")
	sb.WriteString("  (design\n")
	sb.WriteString(fmt.Sprintf("    (source \"%s\")\n", n.Name))
	sb.WriteString("    (tool \"pcb-tracer 0.1.0\")\n")
	sb.WriteString("  )\n")

	// Components
	sb.WriteString("  (components\n")
	for _, comp := range n.Components {
		sb.WriteString(fmt.Sprintf("    (comp (ref \"%s\")\n", comp.ID))
		if comp.PartNumber != "" {
			sb.WriteString(fmt.Sprintf("      (value \"%s\")\n", comp.PartNumber))
		}
		if comp.Package != "" {
			sb.WriteString(fmt.Sprintf("      (footprint \"%s\")\n", comp.Package))
		}
		sb.WriteString("    )\n")
	}
	sb.WriteString("  )\n")

	// Nets
	sb.WriteString("  (nets\n")
	for i, net := range n.Nets {
		sb.WriteString(fmt.Sprintf("    (net (code \"%d\") (name \"%s\")\n", i+1, net.Name))
		for _, conn := range net.Connections {
			sb.WriteString(fmt.Sprintf("      (node (ref \"%s\") (pin \"%d\"))\n", conn.ComponentID, conn.PinNumber))
		}
		sb.WriteString("    )\n")
	}
	sb.WriteString("  )\n")

	// Footer
	sb.WriteString(")\n")

	return os.WriteFile(path, []byte(sb.String()), 0644)
}

// ExportSPICE exports the netlist in SPICE format (.cir).
func (n *Netlist) ExportSPICE(path string) error {
	var sb strings.Builder

	// Title
	sb.WriteString(fmt.Sprintf("* %s\n", n.Name))
	sb.WriteString("* Generated by pcb-tracer\n")
	sb.WriteString("\n")

	// Components as comments (SPICE needs device models)
	sb.WriteString("* Components:\n")
	for _, comp := range n.Components {
		sb.WriteString(fmt.Sprintf("* %s: %s (%s)\n", comp.ID, comp.PartNumber, comp.Package))
	}
	sb.WriteString("\n")

	// Nets
	sb.WriteString("* Nets:\n")
	for _, net := range n.Nets {
		sb.WriteString(fmt.Sprintf("* %s:", net.Name))
		for _, conn := range net.Connections {
			sb.WriteString(fmt.Sprintf(" %s.%d", conn.ComponentID, conn.PinNumber))
		}
		sb.WriteString("\n")
	}
	sb.WriteString("\n")

	// End
	sb.WriteString(".END\n")

	return os.WriteFile(path, []byte(sb.String()), 0644)
}

// PinRef identifies a component pin or connector pin for the dump format.
type PinRef struct {
	Component string // Component ID (e.g., "A12") or "CONN" for connectors
	Pin       string // Pin number/name
	Signal    string // Signal name if known
}

func (p PinRef) String() string {
	if p.Signal != "" {
		return fmt.Sprintf("%s-%s(%s)", p.Component, p.Pin, p.Signal)
	}
	return fmt.Sprintf("%s-%s", p.Component, p.Pin)
}

// PinConnection describes one pin and everything it connects to.
type PinConnection struct {
	Pin       PinRef
	NetName   string
	ConnectsTo []PinRef
}

// ComponentDump groups all pin connections for one component.
type ComponentDump struct {
	ComponentID string
	Pins        []PinConnection
}

// NetlistDump is the brute-force dump of all component pin connections.
type NetlistDump struct {
	Components []ComponentDump
}

// GenerateNetlistDump builds a brute-force dump from electrical nets.
// For each component, lists every pin and what other pins/connectors share its net.
// viaResolver maps via ID → (componentID, pinNumber, signalName).
// connResolver maps connector ID → (pinNumber, signalName).
func GenerateNetlistDump(
	nets []*ElectricalNet,
	viaResolver func(viaID string) (componentID, pinNumber, signalName string),
	connResolver func(connID string) (pinNumber int, signalName string),
) *NetlistDump {
	// Step 1: Build a map of net name → all PinRefs in that net (excluding traces)
	type netPins struct {
		name string
		pins []PinRef
	}
	var netList []netPins

	for _, net := range nets {
		var pins []PinRef

		// Resolve vias to component pins
		for _, viaID := range net.ViaIDs {
			compID, pinNum, sigName := viaResolver(viaID)
			if compID == "" {
				continue // unassigned via, skip
			}
			pins = append(pins, PinRef{
				Component: compID,
				Pin:       pinNum,
				Signal:    sigName,
			})
		}

		// Resolve connectors
		for _, connID := range net.ConnectorIDs {
			pinNum, sigName := connResolver(connID)
			label := fmt.Sprintf("%d", pinNum)
			pins = append(pins, PinRef{
				Component: "CONN",
				Pin:       label,
				Signal:    sigName,
			})
		}

		// Resolve pads (component pins added directly)
		for _, padID := range net.PadIDs {
			parts := strings.SplitN(padID, ".", 2)
			if len(parts) == 2 {
				pins = append(pins, PinRef{
					Component: parts[0],
					Pin:       parts[1],
				})
			}
		}

		if len(pins) > 0 {
			netList = append(netList, netPins{name: net.Name, pins: pins})
		}
	}

	// Step 2: Build per-component pin connections
	// compPins: componentID → pinNumber → PinConnection
	compPins := make(map[string]map[string]*PinConnection)

	for _, np := range netList {
		for _, pin := range np.pins {
			if _, ok := compPins[pin.Component]; !ok {
				compPins[pin.Component] = make(map[string]*PinConnection)
			}
			if _, ok := compPins[pin.Component][pin.Pin]; !ok {
				compPins[pin.Component][pin.Pin] = &PinConnection{
					Pin:     pin,
					NetName: np.name,
				}
			}
			// Add all other pins in this net as connections
			pc := compPins[pin.Component][pin.Pin]
			for _, other := range np.pins {
				if other.Component == pin.Component && other.Pin == pin.Pin {
					continue
				}
				// Avoid duplicates
				found := false
				for _, existing := range pc.ConnectsTo {
					if existing.Component == other.Component && existing.Pin == other.Pin {
						found = true
						break
					}
				}
				if !found {
					pc.ConnectsTo = append(pc.ConnectsTo, other)
				}
			}
		}
	}

	// Step 3: Sort and build output
	var compIDs []string
	for id := range compPins {
		compIDs = append(compIDs, id)
	}
	sort.Strings(compIDs)

	dump := &NetlistDump{}
	for _, compID := range compIDs {
		pins := compPins[compID]
		var pinNums []string
		for p := range pins {
			pinNums = append(pinNums, p)
		}
		// Sort pins numerically where possible
		sort.Slice(pinNums, func(i, j int) bool {
			// Try numeric comparison
			var ni, nj int
			if _, err := fmt.Sscanf(pinNums[i], "%d", &ni); err == nil {
				if _, err := fmt.Sscanf(pinNums[j], "%d", &nj); err == nil {
					return ni < nj
				}
			}
			return pinNums[i] < pinNums[j]
		})

		cd := ComponentDump{ComponentID: compID}
		for _, p := range pinNums {
			cd.Pins = append(cd.Pins, *pins[p])
		}
		dump.Components = append(dump.Components, cd)
	}

	return dump
}

// FormatText formats the dump as readable text.
func (d *NetlistDump) FormatText() string {
	var sb strings.Builder
	for _, comp := range d.Components {
		sb.WriteString(fmt.Sprintf("=== %s ===\n", comp.ComponentID))
		for _, pc := range comp.Pins {
			if len(pc.ConnectsTo) == 0 {
				sb.WriteString(fmt.Sprintf("  pin %-4s [%s] (no connections)\n", pc.Pin.Pin, pc.NetName))
				continue
			}
			var others []string
			for _, o := range pc.ConnectsTo {
				others = append(others, o.String())
			}
			sb.WriteString(fmt.Sprintf("  pin %-4s [%s] -> %s\n", pc.Pin.Pin, pc.NetName, strings.Join(others, ", ")))
		}
		sb.WriteString("\n")
	}
	return sb.String()
}

// ExportText writes the dump to a text file.
func (d *NetlistDump) ExportText(path string) error {
	return os.WriteFile(path, []byte(d.FormatText()), 0644)
}

// Statistics returns statistics about the netlist.
type Statistics struct {
	ComponentCount int
	NetCount       int
	ConnectionCount int
	UnconnectedPins int
}

// GetStatistics returns statistics about the netlist.
func (n *Netlist) GetStatistics() Statistics {
	stats := Statistics{
		ComponentCount: len(n.Components),
		NetCount:       len(n.Nets),
	}

	connectedPins := make(map[string]bool)
	for _, net := range n.Nets {
		stats.ConnectionCount += len(net.Connections)
		for _, conn := range net.Connections {
			key := fmt.Sprintf("%s.%d", conn.ComponentID, conn.PinNumber)
			connectedPins[key] = true
		}
	}

	// Count unconnected pins
	for _, comp := range n.Components {
		for _, pin := range comp.Pins {
			key := fmt.Sprintf("%s.%d", comp.ID, pin.Number)
			if !connectedPins[key] {
				stats.UnconnectedPins++
			}
		}
	}

	return stats
}
